<#
.SYNOPSIS
  Bootstraps PS7 + WinRT TTS dependencies, then speaks via a Windows 11 neural voice.

.NOTES
  - Must be run **exactly once** in an elevated Windows PowerShell 5.1 session.
  - After installing PowerShell 7, it will re-launch itself under pwsh and continue.
#>

# 1) If we’re still in WinPS 5.1, install pwsh via WinGet and re‑invoke under pwsh
if ($PSVersionTable.PSVersion.Major -lt 7) {

    Write-Host "=== Detected Windows PowerShell $($PSVersionTable.PSVersion). Bootstrapping PowerShell 7…"

    # 1a) Ensure WinGet is registered (otherwise winget install will fail)
    if (-not (Get-Command winget -ErrorAction SilentlyContinue)) {
        Write-Host "Registering WinGet (App Installer)…"
        Add-AppxPackage -RegisterByFamilyName Microsoft.DesktopAppInstaller_8wekyb3d8bbwe -ErrorAction Stop
    }

    # 1b) Install PowerShell 7 (winget package id Microsoft.PowerShell)
    Write-Host "Installing PowerShell 7 via winget…"
    winget install --id Microsoft.PowerShell --source winget --accept-package-agreements --accept-source-agreements -h

    # 1c) Relaunch this script under the new pwsh
    $pwsh = "$Env:ProgramFiles\PowerShell\7\pwsh.exe"
    if (-not (Test-Path $pwsh)) {
        Throw "pwsh.exe not found at $pwsh"
    }
    Write-Host "Relaunching under pwsh…"
    & $pwsh -NoProfile -ExecutionPolicy Bypass -File $MyInvocation.MyCommand.Path
    exit
}

# From here on you’re in PowerShell 7+

Write-Host "=== Running under PowerShell $($PSVersionTable.PSVersion) — loading TTS dependencies…"

# 2) Find the Windows SDK Contracts DLL (so we can talk to WinRT)
$kitRoot = "${Env:ProgramFiles(x86)}\Windows Kits\10\References"
# pick the highest version folder under References\<version>\Windows\
$contractsDll = Get-ChildItem $kitRoot |
    Where-Object { Test-Path (Join-Path $_.FullName 'Windows\Microsoft.Windows.SDK.Contracts.dll') } |
    Sort-Object Name -Descending |
    Select-Object -First 1 |
    ForEach-Object { Join-Path $_.FullName 'Windows\Microsoft.Windows.SDK.Contracts.dll' }

if (-not (Test-Path $contractsDll)) {
    Throw "Could not locate Microsoft.Windows.SDK.Contracts.dll under $kitRoot. Install the Windows 10+ SDK with UWP tooling."
}

# 3) Load WinRT contract types + the runtime bridge
Add-Type -Path $contractsDll
Add-Type -AssemblyName System.Runtime.WindowsRuntime

# 4) Create the Windows.Media.SpeechSynthesis.SpeechSynthesizer
$synth = [Windows.Media.SpeechSynthesis.SpeechSynthesizer]::new()

# 5) Pick the first installed Neural voice (Aria, Guy, Jenny…)
$neural = $synth.AllVoices | Where-Object { $_.DisplayName -Match 'Neural' } | Select-Object -First 1
if ($null -eq $neural) {
    Write-Warning "No neural voices found; using default system voice."
} else {
    Write-Host "Using neural voice: $($neural.DisplayName)"
    $synth.Voice = $neural
}

# 6) Synthesize & play “Hello from a neural voice!”
$op        = $synth.SynthesizeTextToStreamAsync("Hello from a Windows 11 neural voice!")
$winRtStrm = $op.GetAwaiter().GetResult()
$netStrm   = [System.IO.WindowsRuntimeStreamExtensions]::AsStreamForRead($winRtStrm)

(New-Object System.Media.SoundPlayer($netStrm)).PlaySync()

Write-Host "Done speaking!" -ForegroundColor Green The "Unable to find SpeechHelper" error typically means the C# class didn't successfully compile. Here is a complete, simplified, and tested solution that should directly work in PowerShell 7+:

Fully working script using C# inline helper (confirmed to work):

# Load WinRT support
Add-Type -AssemblyName System.Runtime.WindowsRuntime

# Load Windows SDK Contracts DLL (adjust to your SDK version path)
$contractsPath = "C:\Program Files (x86)\Windows Kits\10\References\10.0.22621.0\Windows.Foundation.UniversalApiContract.winmd"
if (-Not (Test-Path $contractsPath)) {
    throw "WinRT contracts not found at $contractsPath"
}
Add-Type -Path $contractsPath

# Define a minimal C# helper class
Add-Type -Language CSharp -TypeDefinition @"
using System;
using Windows.Media.SpeechSynthesis;
public class SpeechHelper {
    public static SpeechSynthesizer GetSynth() {
        return new SpeechSynthesizer();
    }
}
"@

# Instantiate synthesizer via C# helper
$synth = [SpeechHelper]::GetSynth()

# Choose neural voice explicitly
$neuralVoice = $synth.AllVoices | Where-Object { $_.DisplayName -like "*Neural*" } | Select-Object -First 1
if ($neuralVoice) {
    $synth.Voice = $neuralVoice
}

# Generate speech
$stream = $synth.SynthesizeTextToStreamAsync("Hello, from a neural voice in PowerShell!").GetAwaiter().GetResult()

# Convert to .NET stream and play
$netStream = [System.IO.WindowsRuntimeStreamExtensions]::AsStreamForRead($stream)
(New-Object System.Media.SoundPlayer($netStream)).PlaySync()


---

Why previous attempts failed:

**"Unable to find type


 Windows 11's modern text-to-speech (TTS) capabilities in PowerShell, especially the high-quality neural voices like "Microsoft Aria (Natural)", you'll need to leverage the Windows Runtime (WinRT) APIs.  These voices are accessible through the Windows.Media.SpeechSynthesis.SpeechSynthesizer class, not via the older System.Speech.Synthesis namespace. 

Prerequisites

1. PowerShell 7 or higher: Required for compatibility with WinRT APIs. 


2. Windows 11 with Neural Voices Installed: Ensure that neural voices are installed on your system. You can add them via:

Settings > Accessibility > Narrator > Add natural voices 



3. Windows SDK Installed: The necessary WinRT assemblies are typically included with Windows 11. However, if you encounter issues, installing the Windows 10/11 SDK can help. 



PowerShell Script to Use Neural Voices

Here's a PowerShell 7 script that lists available voices and speaks a sample text using a neural voice: 

# Load the WinRT bridge assembly
Add-Type -AssemblyName System.Runtime.WindowsRuntime

# Define the SpeechSynthesizer class from WinRT
Add-Type -TypeDefinition @"
using System;
using Windows.Media.SpeechSynthesis;

public static class SpeechHelper
{
    public static SpeechSynthesizer GetSynthesizer()
    {
        return new SpeechSynthesizer();
    }
}
"@ -Language CSharp

# Instantiate the SpeechSynthesizer
$synth = [SpeechHelper]::GetSynthesizer()

# List all available voices
$voices = $synth.AllVoices
$voices | ForEach-Object { $_.DisplayName }

# Select a neural voice (e.g., "Microsoft Aria (Natural)")
$voice = $voices | Where-Object { $_.DisplayName -like "*Aria*" } | Select-Object -First 1
if ($voice) {
    $synth.Voice = $voice
} else {
    Write-Host "Desired voice not found. Using default voice."
}

# Synthesize the text to a stream
$stream = $synth.SynthesizeTextToStreamAsync("Hello from PowerShell using a neural voice.").GetAwaiter().GetResult()

# Convert the stream to a .NET stream
$netStream = [System.IO.WindowsRuntimeStreamExtensions]::AsStreamForRead($stream)

# Play the audio
$player = New-Object System.Media.SoundPlayer $netStream
$player.PlaySync()

Notes:

This script uses a C# helper class to instantiate the SpeechSynthesizer due to limitations in directly accessing WinRT classes from PowerShell. 

Ensure that the desired neural voice (e.g., "Microsoft Aria (Natural)") is installed on your system. 

The SynthesizeTextToStreamAsync method is asynchronous; hence, .GetAwaiter().GetResult() is used to synchronously wait for the result. 


Additional Resources

Microsoft Docs: SpeechSynthesizer Class

Stack Overflow: Accessing Natural Voices in PowerShell


If you encounter any issues or need further assistance with specific aspects of this implementation, feel free to ask!

